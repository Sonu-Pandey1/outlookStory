generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  userId         String       @id @map("_id") // Clerk's userId (this is now the primary key)
  name       String?
  email      String?      @unique
  image      String?
  createdAt  DateTime?    @default(now())
  updatedAt  DateTime?    @updatedAt
  posts      Post[] // Relation to posts
  comments   Comment[] // Relation to comments
  role       String? // Optional role field
  likes      Like[] // Likes
  savedPosts SavedPosts[] // Saved posts
}

model Post {
  id         String       @id @default(cuid()) @map("_id")
  createdAt  DateTime     @default(now())
  updatedAt  DateTime?    @updatedAt
  slug       String       @unique
  title      String
  desc       String
  img        String?
  views      Int          @default(0)
  catSlug    String
  cat        Category     @relation(fields: [catSlug], references: [slug])
  userId     String // User's ID (userId, not id)
  user       User         @relation(fields: [userId], references: [userId],onDelete: Cascade) // Relation to User's userId
  comments   Comment[]
  likes      Like[]
  savedPosts SavedPosts[]
}

model Comment {
  id        String   @id @default(cuid()) @map("_id")
  createdAt DateTime @default(now())
  updatedAt  DateTime?    @updatedAt
  desc      String
  userId    String // Relating comment to user's userId
  user      User     @relation(fields: [userId], references: [userId],onDelete: Cascade) // Relating to User's userId
  postSlug  String
  post      Post     @relation(fields: [postSlug], references: [slug])
}
// model Comment {
//   id        Int      @id @default(autoincrement())
//   createdAt DateTime @default(now())
//   desc      String
//   userId    Int?
//   user      User?    @relation(fields: [userId], references: [id])
//   postSlug  String
//   post      Post     @relation(fields: [postSlug], references: [slug])
// }


model Category {
  id    String  @id @default(cuid()) @map("_id")
  slug  String  @unique
  title String
  img   String?
  posts Post[]
}

model Like {
  id        String   @id @default(cuid()) @map("_id")
  createdAt DateTime @default(now())
  userId    String // User's ID (userId)
  postId    String // Post's ID
  user      User     @relation(fields: [userId], references: [userId],onDelete: Cascade) // Relation to User
  post      Post     @relation(fields: [postId], references: [id]) // Relation to Post

  @@unique([userId, postId]) // A user can only like a post once
}

model SavedPosts {
  id        String   @id @default(cuid()) @map("_id")
  createdAt DateTime @default(now())
  userId    String // User's ID (userId)
  postId    String // Post's ID
  user      User     @relation(fields: [userId], references: [userId],onDelete: Cascade) // Relation to User
  post      Post     @relation(fields: [postId], references: [id]) // Relation to Post

  @@unique([userId, postId]) // A user can only save a post once
}


// last chetgpt conv --

// Message: Error in Prisma Client request: 


// Invalid U=n.match(q7n)?.[1]??"",ee=n.match($7n)?.[1]??null,ne=n.match(U7n)?.[1]??null,{getPrismaClient:ve,PrismaClientKnownRequestError:Se,PrismaClientRustPanicError:Oe,PrismaClientInitializationError:it,PrismaClientValidationError:et}=require(${D.prismaClient}/runtime/${T}),ot=n,Vt=(0,Mrt.createHash)("sha256").update() invocation in
// C:\Users\Sonu\Desktop\outlookStory\node_modules\prisma\build\index.js:2323:10489

//   2320       }
//   2321     }
//   2322   }
// → 2323 }});return Pu.resourceList(p.workspaces)}};var llr=require("@prisma/engines");var jnr=require("buffer");function Bnr(n,i,a,u){Object.defineProperty(n,i,{get:a,set:u,enumerable:!0,configurable:!0})}var qnr={};Bnr(qnr,"serializeRPCMessage",()=>ett);Bnr(qnr,"deserializeRPCMessage",()=>ttt);var Ket="PrismaBigInt::",Zet="PrismaBytes::";function ett(n){return JSON.stringify(n,(i,a)=>typeof a=="bigint"?Ket+a:a?.type==="Buffer"&&Array.isArray(a?.data)?Zet+jnr.Buffer.from(a.data).toString("base64"):a)}function ttt(n){return JSON.parse(n,(i,a)=>typeof a=="string"&&a.startsWith(Ket)?BigInt(a.substr(Ket.length)):typeof a=="string"&&a.startsWith(Zet)?a.substr(Zet.length):a)}var tlr=Ir(Gnr()),cke=Ir(qcr()),rlr=Ir(require("http")),nlr=Ir(Wcr()),ilr=require("zlib");var dA=require("path");var Mrt=require("crypto"),Qcr=Ir(Nrt());function Rrt(n,i,a,u){Object.defineProperty(n,i,{get:a,set:u,enumerable:!0,configurable:!0})}var Kcr=globalThis,Ort={},oke={},wj=Kcr.parcelRequire1308;wj==null&&(wj=function(n){if(n in Ort)return Ort[n].exports;if(n in oke){var i=oke[n];delete oke[n];var a={id:n,exports:{}};return Ort[n]=a,i.call(a.exports,a,a.exports),a.exports}var u=new Error("Cannot find module '"+n+"'");throw u.code="MODULE_NOT_FOUND",u},wj.register=function(i,a){oke[i]=a},Kcr.parcelRequire1308=wj);var Zcr=wj.register;Zcr("9lTzd",function(module,exports){Rrt(module.exports,"guessEnginePaths",()=>guessEnginePaths),Rrt(module.exports,"guessPrismaClientPath",()=>guessPrismaClientPath);var $5COlq=wj("5COlq");async function guessEnginePaths({forceBinary,forceLibrary,resolveOverrides}){let queryEngineName,queryEngineType;if(forceLibrary?(queryEngineName=await(0,$5COlq.prismaEngineName)("query-engine","library"),queryEngineType="library"):forceBinary?(queryEngineName=await(0,$5COlq.prismaEngineName)("query-engine","binary"),queryEngineType="binary"):(queryEngineName=void 0,queryEngineType=void 0),!queryEngineName||!queryEngineType)return{queryEngine:void 0};let queryEnginePath;if(resolveOverrides[".prisma/client"])queryEnginePath=(0,dA.resolve)(resolveOverrides[".prisma/client"],../${queryEngineName});else if(resolveOverrides["@prisma/engines"])queryEnginePath=(0,dA.resolve)(resolveOverrides["@prisma/engines"],../../${queryEngineName});else{let atPrismaEnginesPath;try{atPrismaEnginesPath=eval("require.resolve('@prisma/engines')")}catch(n){throw new Error("Unable to resolve Prisma engine paths. This is a bug.")}queryEnginePath=(0,dA.resolve)(atPrismaEnginesPath../../${queryEngineName})}return{queryEngine:{type:queryEngineType,path:queryEnginePath}}}function guessPrismaClientPath({resolveOverrides}){let prismaClientPath=resolveOverrides["@prisma/client"]||eval("require.resolve('@prisma/client')");return(0,dA.resolve)(prismaClientPath,"../")}});Zcr("5COlq",function(n,i){Rrt(n.exports,"prismaEngineName",()=>a);async function a(u,p){let x=await Ay(),T=x==="windows"?".exe":"";if(p==="library")return w6(x,"fs");if(p==="binary")return${u}-${x}${T};throw new Error(Unknown engine type: ${p})}});function B7n(n){return{models:Frt(n.models),enums:Frt(n.enums),types:Frt(n.types)}}function Frt(n){let i={};for(let{name:a,...u}of n)i[a]=u;return i}var Ooe=(0,Qcr.debug)("prisma:studio-pcw"),q7n=/^\s*datasource\s+([^\s]+)\s*{/m,$7n=/url *= *env\("(.*)"\)/,U7n=/url *= *"(.*)"/;async function W7n({schema:n,schemaPath:i,dmmf:a,datasourceProvider:u,previewFeatures:p,datasources:x,engineType:T,paths:D,directUrl:R,versions:L}){let U=n.match(q7n)?.[1]??"",ee=n.match($7n)?.[1]??null,ne=n.match(U7n)?.[1]??null,{getPrismaClient:ve,PrismaClientKnownRequestError:Se,PrismaClientRustPanicError:Oe,PrismaClientInitializationError:it,PrismaClientValidationError:et}=require(${D.prismaClient}/runtime/${T}),ot=n,Vt=(0,Mrt.createHash)("sha256").update(
// Inconsistent query result: Field user is required to return data, got null instead.
  
// Query:
// {
//   "modelName": "Comment",
//   "operation": "findMany",
//   "args": {
//     "take": 100,
//     "skip": 0,
//     "select": {
//       "id": true,
//       "createdAt": true,
//       "desc": true,
//       "userId": true,
//       "user": true,
//       "postSlug": true,
//       "post": true
//     }
//   }
// }
  
// ChatGPT said:
// The error you're encountering indicates that the Prisma query you executed is trying to fetch data from the user field, but it's encountering a null value for user. The Prisma error message states: "Inconsistent query result: Field user is required to return data, got null instead."

// This error typically happens when your Prisma query expects user to always be available (as indicated by your select clause), but in some cases, it's missing or null. Prisma enforces that if a field is selected in the query, it must return a valid result.

// Steps to Fix:
// Allow Null for the user Field in Prisma Schema: First, check your Prisma schema (schema.prisma) to ensure that the user field is correctly set up to handle null values. For instance:

// prisma
// Copy
// model Comment {
//   id        Int      @id @default(autoincrement())
//   createdAt DateTime @default(now())
//   desc      String
//   userId    Int?
//   user      User?    @relation(fields: [userId], references: [id])
//   postSlug  String
//   post      Post     @relation(fields: [postSlug], references: [slug])
// }
// In the example above, userId is an optional field (Int?), and user is a relation that can also be null (indicated by User?).
// Modify the Prisma Query to Handle Null user: To avoid errors when user is null, you can either:

// Modify the select to handle null values gracefully, or
// Update your query logic to handle cases where user might be null.
// Here's an updated query where we check for null user values:

// js
// Copy
// const comments = await prisma.comment.findMany({
//   take: 100,
//   skip: 0,
//   select: {
//     id: true,
//     createdAt: true,
//     desc: true,
//     userId: true,
//     user: {
//       select: {
//         id: true,
//         name: true,
//         image: true
//       }
//     },
//     postSlug: true,
//     post: true
//   }
// });

// // Ensure that `user` is not null when accessing it
// const safeComments = comments.map(comment => ({
//   ...comment,
//   user: comment.user || { name: 'Anonymous', image: '/default-avatar.png' } // Fallback to anonymous user
// }));
// Check Data Consistency: If user is expected to be present but is null in some cases, you may want to check your data and ensure that every Comment entry has a valid user. If user is sometimes missing, you may need to review how data is being created or updated in the database to ensure data consistency.

// Explanation of Changes:
// userId Field: The userId is nullable (Int?), which means that comments may not always have a user associated with them.
// user Field: The user relation can also be null if there is no associated user.
// Fallback for null user: In the mapping logic, I provided a fallback for user so that if it's null, it will default to an anonymous user with a default avatar.
// By implementing these changes, you should be able to resolve the issue and avoid the Prisma error when user is missing in some comments.

// Let me know if this helps or if you have further questions!


// //!

// 2. Preserve User Data (Soft Delete or Transfer Data)
// If you want to preserve the user’s data but mark them as deleted (soft delete), or transfer their posts/comments to another user, you can follow one of these strategies:

// Option 1: Soft Delete
// This approach doesn't delete the user's data but marks them as "deleted" in the database by adding a deletedAt field. You can then filter out deleted users from your UI.

// Prisma Schema Changes (Soft Delete)
// Add a deletedAt field to the User model in your Prisma schema:

// prisma
// Copy
// model User {
//   userId    String   @id @default(cuid())
//   name      String
//   email     String   @unique
//   posts     Post[]
//   comments  Comment[]
//   deletedAt DateTime? // Nullable field to mark soft deletion
// }
// Soft Delete Logic
// Instead of actually deleting the user, you can just set the deletedAt field:

// javascript
// Copy
// export async function DELETE(req) {
//   const { userId } = await req.json();

//   if (!userId) {
//     return new NextResponse(
//       JSON.stringify({ message: "Missing userId" }),
//       { status: 400 }
//     );
//   }

//   try {
//     // Soft delete the user (set deletedAt to current timestamp)
//     const updatedUser = await prisma.user.update({
//       where: { userId },
//       data: { deletedAt: new Date() },
//     });

//     return new NextResponse(
//       JSON.stringify({ message: "User soft deleted", updatedUser }),
//       { status: 200 }
//     );
//   } catch (error) {
//     console.error("Error soft deleting user:", error);
//     return new NextResponse(
//       JSON.stringify({ message: "Failed to soft delete user", error: error.message }),
//       { status: 500 }
//     );
//   }
// }
// Option 2: Transfer Data to Another User
// If you want to preserve the user’s posts and comments but transfer them to another user (e.g., an admin or another user), you can update the related posts/comments to point to a different user.

// Transfer User's Data to Another User
// Here’s how you can transfer a user’s posts/comments to another user:

// javascript
// Copy
// export async function DELETE(req) {
//   const { userId, transferToUserId } = await req.json();

//   if (!userId || !transferToUserId) {
//     return new NextResponse(
//       JSON.stringify({ message: "Missing userId or transferToUserId" }),
//       { status: 400 }
//     );
//   }

//   try {
//     // Transfer posts and comments to another user
//     await prisma.post.updateMany({
//       where: { userId },
//       data: { userId: transferToUserId }, // Transfer posts to another user
//     });

//     await prisma.comment.updateMany({
//       where: { userId },
//       data: { userId: transferToUserId }, // Transfer comments to another user
//     });

//     // Now delete the user
//     const deletedUser = await prisma.user.delete({
//       where: { userId },
//     });

//     return new NextResponse(
//       JSON.stringify({ message: "User deleted, data transferred", deletedUser }),
//       { status: 200 }
//     );
//   } catch (error) {
//     console.error("Error deleting user:", error);
//     return new NextResponse(
//       JSON.stringify({ message: "Failed to delete user", error: error.message }),
//       { status: 500 }
//     );
//   }
// }
// Key Considerations:
// Cascade Deletion: If you want to delete the user and all related data, ensure the relationships are set up correctly in your Prisma schema with onDelete: Cascade. This will delete posts, comments, etc., along with the user.
// Soft Deletion: If you want to preserve the user’s data, you can soft delete by adding a deletedAt field and setting it when a user is deleted.
// Transfer Data: If you want to keep posts/comments but transfer them to another user, update the related data to point to another userId.
// Conclusion:
// If you want a full deletion, ensure the relationships are set to CASCADE in Prisma, and you can delete the user and all related data.
// If you want to preserve the user’s data, use soft deletion by setting a deletedAt field, or transfer the posts/comments to another user before deleting.
// Let me know if you need further clarifications!